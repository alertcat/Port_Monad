<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Port Monad 3D World</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=IBM+Plex+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #09090b;
            --panel: #111118;
            --line: #2a2a34;
            --text: #f4f4f5;
            --muted: #9ca3af;
            --good: #31d38d;
            --bad: #ff6b6b;
            --accent: #c084fc;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: "IBM Plex Sans", sans-serif;
            background:
                radial-gradient(circle at 20% 12%, #0f2045 0%, transparent 42%),
                radial-gradient(circle at 88% 6%, #2a183e 0%, transparent 36%),
                linear-gradient(165deg, #05070d 0%, #090f1b 55%, #060a11 100%);
            color: var(--text);
            overflow: hidden;
            min-height: 100vh;
        }

        .app {
            display: grid;
            grid-template-columns: 320px 1fr 350px;
            grid-template-rows: 72px 1fr;
            height: 100vh;
        }

        .topbar {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 10px 14px;
            border-bottom: 1px solid var(--line);
            background: linear-gradient(180deg, rgba(12, 16, 26, 0.95), rgba(7, 10, 17, 0.92));
            backdrop-filter: blur(4px);
        }

        .brand {
            font-family: "Orbitron", sans-serif;
            font-size: 18px;
            letter-spacing: 1.2px;
            text-transform: uppercase;
            margin-right: 8px;
            white-space: nowrap;
        }

        .brand b {
            color: #c084fc;
            font-weight: 700;
        }

        .meta {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--muted);
            font-size: 13px;
            white-space: nowrap;
        }

        .pill {
            border: 1px solid #275f46;
            background: rgba(17, 56, 43, 0.45);
            color: #5ef3b0;
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 12px;
        }

        .pill.offline {
            border-color: #7a3748;
            background: rgba(94, 36, 46, 0.4);
            color: #ffa3b4;
        }

        .toolbar {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .btn {
            border: 1px solid #33507a;
            background: linear-gradient(180deg, #16243c, #111b2f);
            color: #dfe9ff;
            border-radius: 8px;
            padding: 7px 10px;
            font-size: 12px;
            cursor: pointer;
            transition: transform 120ms ease, border-color 120ms ease, background 140ms ease;
        }

        .btn:hover {
            transform: translateY(-1px);
            border-color: #59bfff;
        }

        .btn.active {
            border-color: #c084fc;
            background: linear-gradient(180deg, #3b2a55, #302145);
            color: #f8f5ff;
        }

        .link {
            text-decoration: none;
            border: 1px solid #455a7e;
            color: #d9e9ff;
            border-radius: 8px;
            padding: 7px 10px;
            font-size: 12px;
            background: rgba(18, 25, 39, 0.75);
        }

        .sidebar,
        .inspector {
            overflow-y: auto;
            background: linear-gradient(180deg, rgba(13, 20, 35, 0.95), rgba(10, 15, 27, 0.92));
        }

        .sidebar {
            border-right: 1px solid var(--line);
            padding: 14px;
        }

        .inspector {
            border-left: 1px solid var(--line);
            padding: 14px;
        }

        #scene-wrap {
            position: relative;
            min-height: 0;
        }

        #scene {
            width: 100%;
            height: 100%;
        }

        .hud-note {
            position: absolute;
            left: 12px;
            bottom: 10px;
            border: 1px solid rgba(69, 106, 168, 0.45);
            background: rgba(8, 12, 20, 0.75);
            color: #aac1ea;
            border-radius: 8px;
            font-size: 11px;
            line-height: 1.45;
            padding: 8px 10px;
            pointer-events: none;
        }

        .section {
            margin-bottom: 14px;
        }

        .section h3 {
            font-family: "Orbitron", sans-serif;
            font-size: 12px;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: #b7c9ef;
            margin-bottom: 8px;
        }

        .card {
            border: 1px solid #2f4060;
            border-radius: 10px;
            background: linear-gradient(180deg, rgba(20, 31, 51, 0.86), rgba(16, 24, 40, 0.86));
            padding: 10px;
            margin-bottom: 8px;
        }

        .muted {
            color: var(--muted);
            font-size: 12px;
        }

        .agent-name {
            font-size: 14px;
            font-weight: 700;
            max-width: 180px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .agent-meta {
            margin-top: 4px;
            color: #aec1e4;
            font-size: 12px;
            overflow-wrap: anywhere;
        }

        .row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .row + .row {
            margin-top: 6px;
        }

        .chip {
            font-size: 11px;
            padding: 3px 7px;
            border-radius: 999px;
            border: 1px solid #425272;
            color: #d5e4ff;
        }

        .region-count {
            font-size: 12px;
            color: #bed1f2;
        }

        .list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .item {
            border: 1px solid #2f4060;
            border-radius: 10px;
            background: linear-gradient(180deg, rgba(20, 31, 51, 0.86), rgba(16, 24, 40, 0.86));
            padding: 8px;
        }

        .item .head {
            color: #d8e8ff;
            font-size: 12px;
            font-weight: 700;
        }

        .item .body {
            margin-top: 3px;
            font-size: 12px;
            color: #a9bad8;
            line-height: 1.35;
            overflow-wrap: anywhere;
            word-break: break-word;
        }

        .price-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .price-cell {
            border: 1px solid #2f4060;
            border-radius: 10px;
            background: linear-gradient(180deg, rgba(20, 31, 51, 0.86), rgba(16, 24, 40, 0.86));
            text-align: center;
            padding: 10px 8px;
        }

        .price-cell .k {
            color: #9fb5da;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .top-value-tax {
            color: #fbbf24;
        }

        .top-value-pyth {
            color: #60a5fa;
        }

        .region-pill {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            border-radius: 9999px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .region-dock {
            background: rgba(59, 130, 246, 0.15);
            color: #60a5fa;
        }

        .region-mine {
            background: rgba(245, 158, 11, 0.15);
            color: #fbbf24;
        }

        .region-forest {
            background: rgba(34, 197, 94, 0.15);
            color: #4ade80;
        }

        .region-market {
            background: rgba(168, 85, 247, 0.15);
            color: #c084fc;
        }

        .rank-badge {
            font-size: 11px;
            font-weight: 700;
            border-radius: 999px;
            padding: 2px 8px;
            border: 1px solid #3c4e6f;
            background: rgba(37, 49, 72, 0.55);
            color: #dbeafe;
        }

        .rank-1 {
            border-color: rgba(245, 158, 11, 0.55);
            background: rgba(245, 158, 11, 0.15);
            color: #fbbf24;
        }

        .rank-2 {
            border-color: rgba(156, 163, 175, 0.6);
            background: rgba(156, 163, 175, 0.15);
            color: #d1d5db;
        }

        .rank-3 {
            border-color: rgba(217, 119, 6, 0.55);
            background: rgba(217, 119, 6, 0.15);
            color: #f59e0b;
        }

        .credits-up {
            color: #22c55e;
            font-weight: 700;
        }

        .action-tag {
            display: inline-flex;
            align-items: center;
            border-radius: 999px;
            padding: 2px 8px;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.35px;
            text-transform: uppercase;
            border: 1px solid transparent;
            margin-left: 4px;
        }

        .action-tag.harvest {
            background: rgba(34, 197, 94, 0.15);
            color: #4ade80;
            border-color: rgba(34, 197, 94, 0.3);
        }

        .action-tag.move {
            background: rgba(59, 130, 246, 0.15);
            color: #60a5fa;
            border-color: rgba(59, 130, 246, 0.3);
        }

        .action-tag.place_order {
            background: rgba(168, 85, 247, 0.15);
            color: #c084fc;
            border-color: rgba(168, 85, 247, 0.35);
        }

        .action-tag.rest {
            background: rgba(113, 113, 122, 0.15);
            color: #a1a1aa;
            border-color: rgba(113, 113, 122, 0.28);
        }

        .action-tag.raid {
            background: rgba(239, 68, 68, 0.15);
            color: #f87171;
            border-color: rgba(239, 68, 68, 0.35);
        }

        .action-tag.negotiate {
            background: rgba(245, 158, 11, 0.15);
            color: #fbbf24;
            border-color: rgba(245, 158, 11, 0.3);
        }

        .action-tag.register {
            background: rgba(34, 197, 94, 0.15);
            color: #4ade80;
            border-color: rgba(34, 197, 94, 0.3);
        }

        .price-cell .v {
            margin-top: 4px;
            font-size: 20px;
            font-weight: 700;
        }

        .accent {
            color: var(--accent);
        }

        .danger {
            color: var(--bad);
        }

        .ok {
            color: var(--good);
        }

        @media (max-width: 1300px) {
            .app {
                grid-template-columns: 1fr;
                grid-template-rows: 72px 56vh auto auto;
                height: auto;
                min-height: 100vh;
            }

            .sidebar {
                border-right: none;
                border-top: 1px solid var(--line);
            }

            .inspector {
                border-left: none;
                border-top: 1px solid var(--line);
            }

            #scene-wrap {
                min-height: 420px;
            }

            .toolbar {
                margin-left: 0;
            }

            .topbar {
                flex-wrap: wrap;
                justify-content: space-between;
            }
        }
    </style>
</head>
<body>
<div class="app">
    <header class="topbar">
        <div class="brand"><b>Port Monad</b> 3D Observer</div>
        <div class="meta">
            <span>Tick <b id="tick" class="accent">-</b></span>
            <span>Agents <b id="agent-count" class="accent">-</b></span>
            <span>Tax <b id="tax" class="top-value-tax">-</b></span>
            <span>MON/USD <b id="sol-price" class="top-value-pyth">-</b></span>
            <span id="conn" class="pill">Connected</span>
        </div>
        <div class="toolbar">
            <button class="btn active" data-camera="overview">Overview</button>
            <button class="btn" data-camera="free">Free Orbit</button>
            <button class="btn" data-camera="follow">Follow Agent</button>
            <button class="btn" data-view="center">Center</button>
            <button class="btn" data-region="dock">Dock</button>
            <button class="btn" data-region="mine">Mine</button>
            <button class="btn" data-region="market">Market</button>
            <button class="btn" data-region="forest">Forest</button>
            <a class="link" href="/game">Legacy 2D</a>
            <a class="link" href="/dashboard">Dashboard</a>
        </div>
    </header>

    <aside class="sidebar">
        <div class="section">
            <h3>Regions</h3>
            <div id="region-list" class="list"></div>
        </div>

        <div class="section">
            <h3>Selected Agent</h3>
            <div id="agent-detail" class="card muted">Click an agent model to inspect details.</div>
        </div>

        <div class="section">
            <h3>Agents</h3>
            <div id="agent-list" class="list">
                <div class="muted">Waiting for agent data...</div>
            </div>
        </div>
    </aside>

    <main id="scene-wrap">
        <div id="scene"></div>
        <div class="hud-note">
            Click region pad: quick camera focus<br>
            Click agent model: select + inspect<br>
            Mouse: rotate and zoom in Free Orbit mode
        </div>
    </main>

    <aside class="inspector">
        <div class="section">
            <h3>Market</h3>
            <div class="price-grid">
                <div class="price-cell"><div class="k">Iron</div><div class="v" id="iron">-</div></div>
                <div class="price-cell"><div class="k">Wood</div><div class="v" id="wood">-</div></div>
                <div class="price-cell"><div class="k">Fish</div><div class="v" id="fish">-</div></div>
            </div>
        </div>

        <div class="section">
            <h3>Events</h3>
            <div id="events" class="list">
                <div class="muted">No active events.</div>
            </div>
        </div>

        <div class="section">
            <h3>Recent Actions</h3>
            <div id="actions" class="list">
                <div class="muted">No recent actions.</div>
            </div>
        </div>
    </aside>
</div>

<script async src="https://ga.jspm.io/npm:es-module-shims@1.10.0/dist/es-module-shims.js"></script>
<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
}
</script>
<script>
(function () {
    function showGame3DError(message) {
        const text = String(message || "3D world failed to initialize");
        let box = document.getElementById("game3d-fatal");
        if (!box) {
            box = document.createElement("div");
            box.id = "game3d-fatal";
            box.style.position = "fixed";
            box.style.left = "16px";
            box.style.bottom = "16px";
            box.style.zIndex = "9999";
            box.style.maxWidth = "70vw";
            box.style.padding = "10px 12px";
            box.style.border = "1px solid #8f3f53";
            box.style.borderRadius = "8px";
            box.style.background = "rgba(56, 15, 24, 0.92)";
            box.style.color = "#ffd9df";
            box.style.font = "12px/1.4 IBM Plex Sans, sans-serif";
            box.style.whiteSpace = "pre-wrap";
            document.body.appendChild(box);
        }
        box.textContent = "3D runtime error: " + text;
    }

    window.__showGame3DError = showGame3DError;
    window.addEventListener("error", (e) => {
        if (e && e.message) showGame3DError(e.message);
    });
    window.addEventListener("unhandledrejection", (e) => {
        const reason = e && e.reason ? (e.reason.stack || e.reason.message || String(e.reason)) : "Unhandled promise rejection";
        showGame3DError(reason);
    });
})();
</script>
<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

const API = window.location.origin;
const fatal = window.__showGame3DError || ((msg) => console.error(msg));

const WORLD_HALF = 84;
const ROAD_HALF = 6;
const ROAD_WIDTH = ROAD_HALF * 2;
const OVERVIEW_POS = new THREE.Vector3(0, 84, 84);

const REGION_CONFIG = {
    dock: {
        label: "Dock",
        color: 0x3b82f6,
        bounds: { minX: -WORLD_HALF, maxX: -ROAD_HALF, minZ: -WORLD_HALF, maxZ: -ROAD_HALF },
        center: new THREE.Vector3(-(WORLD_HALF + ROAD_HALF) / 2, 0, -(WORLD_HALF + ROAD_HALF) / 2),
        gate: new THREE.Vector3(-ROAD_HALF, 0, -ROAD_HALF),
        cameraOffset: new THREE.Vector3(18, 24, 18),
        desc: "Entry zone with water and piers"
    },
    mine: {
        label: "Mine",
        color: 0xf59e0b,
        bounds: { minX: ROAD_HALF, maxX: WORLD_HALF, minZ: -WORLD_HALF, maxZ: -ROAD_HALF },
        center: new THREE.Vector3((WORLD_HALF + ROAD_HALF) / 2, 0, -(WORLD_HALF + ROAD_HALF) / 2),
        gate: new THREE.Vector3(ROAD_HALF, 0, -ROAD_HALF),
        cameraOffset: new THREE.Vector3(-18, 24, 18),
        desc: "Rocky extraction field"
    },
    market: {
        label: "Market",
        color: 0xa855f7,
        bounds: { minX: -WORLD_HALF, maxX: -ROAD_HALF, minZ: ROAD_HALF, maxZ: WORLD_HALF },
        center: new THREE.Vector3(-(WORLD_HALF + ROAD_HALF) / 2, 0, (WORLD_HALF + ROAD_HALF) / 2),
        gate: new THREE.Vector3(-ROAD_HALF, 0, ROAD_HALF),
        cameraOffset: new THREE.Vector3(18, 24, -18),
        desc: "Trading square and stalls"
    },
    forest: {
        label: "Forest",
        color: 0x22c55e,
        bounds: { minX: ROAD_HALF, maxX: WORLD_HALF, minZ: ROAD_HALF, maxZ: WORLD_HALF },
        center: new THREE.Vector3((WORLD_HALF + ROAD_HALF) / 2, 0, (WORLD_HALF + ROAD_HALF) / 2),
        gate: new THREE.Vector3(ROAD_HALF, 0, ROAD_HALF),
        cameraOffset: new THREE.Vector3(-18, 24, -18),
        desc: "Harvest zone with tree cover"
    }
};

const REGION_IDS = Object.keys(REGION_CONFIG);
const CROSSROAD = new THREE.Vector3(0, 0, 0);

let scene;
let camera;
let renderer;
let controls;
let clock;
let raycaster;
let pointer;

let cameraMode = "overview";
let selectedAgentWallet = null;
let selectedRegion = null;
let latestAgents = [];
let activeActions = [];

const regionMeshes = {};
const agentModels = new Map();
const clickableMeshes = [];
const seenActionIds = new Set();
const sunBillboards = [];

const cameraGoal = OVERVIEW_POS.clone();
const lookGoal = new THREE.Vector3(0, 0, 0);

function setConn(ok) {
    const el = document.getElementById("conn");
    el.className = ok ? "pill" : "pill offline";
    el.textContent = ok ? "Connected" : "Disconnected";
}

async function safeFetch(path, affectConn = true) {
    try {
        const res = await fetch(API + path);
        if (!res.ok) {
            if (affectConn) setConn(false);
            return null;
        }
        if (affectConn) setConn(true);
        return await res.json();
    } catch (_err) {
        if (affectConn) setConn(false);
        return null;
    }
}

function hashColor(seed) {
    let h = 0;
    const s = String(seed || "agent");
    for (let i = 0; i < s.length; i += 1) {
        h = (h * 33 + s.charCodeAt(i)) | 0;
    }
    const hue = Math.abs(h) % 360;
    const color = new THREE.Color();
    color.setHSL(hue / 360, 0.65, 0.56);
    return color;
}

function createTextSprite(text, opts = {}) {
    const width = opts.width || 256;
    const height = opts.height || 72;
    const bg = opts.bg || "rgba(8,14,25,0.86)";
    const fg = opts.fg || "#dce9ff";
    const border = opts.border || "rgba(95,165,255,0.5)";
    const font = opts.font || "600 28px IBM Plex Sans";

    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");

    ctx.fillStyle = bg;
    ctx.strokeStyle = border;
    ctx.lineWidth = 2;
    ctx.beginPath();
    const r = 12;
    ctx.moveTo(r, 0);
    ctx.lineTo(width - r, 0);
    ctx.quadraticCurveTo(width, 0, width, r);
    ctx.lineTo(width, height - r);
    ctx.quadraticCurveTo(width, height, width - r, height);
    ctx.lineTo(r, height);
    ctx.quadraticCurveTo(0, height, 0, height - r);
    ctx.lineTo(0, r);
    ctx.quadraticCurveTo(0, 0, r, 0);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.font = font;
    ctx.fillStyle = fg;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text, width / 2, height / 2 + 1);

    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
    const sprite = new THREE.Sprite(material);
    const worldScaleY = opts.scaleY || 1.1;
    sprite.scale.set((width / height) * worldScaleY, worldScaleY, 1);
    return sprite;
}

function makeSunTexture(size = 512) {
    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext("2d");
    const cx = size * 0.5;
    const cy = size * 0.5;

    const grad = ctx.createRadialGradient(cx, cy, size * 0.04, cx, cy, size * 0.5);
    grad.addColorStop(0, "rgba(255,255,245,1)");
    grad.addColorStop(0.16, "rgba(255,245,210,0.98)");
    grad.addColorStop(0.34, "rgba(255,214,122,0.92)");
    grad.addColorStop(0.58, "rgba(255,185,86,0.52)");
    grad.addColorStop(0.84, "rgba(255,155,64,0.18)");
    grad.addColorStop(1, "rgba(255,120,32,0)");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, size, size);

    const rim = ctx.createRadialGradient(cx, cy, size * 0.36, cx, cy, size * 0.5);
    rim.addColorStop(0, "rgba(255,220,150,0)");
    rim.addColorStop(0.72, "rgba(255,205,120,0.06)");
    rim.addColorStop(1, "rgba(255,158,88,0.22)");
    ctx.fillStyle = rim;
    ctx.fillRect(0, 0, size, size);

    const tex = new THREE.CanvasTexture(canvas);
    tex.needsUpdate = true;
    return tex;
}

function seeded2D(x, y, salt = 0) {
    const n = Math.sin((x + salt * 11.7) * 12.9898 + (y + salt * 7.9) * 78.233) * 43758.5453;
    return n - Math.floor(n);
}

function makeRegionTexture(regionId) {
    const size = 256;
    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext("2d");

    if (regionId === "dock") {
        const g = ctx.createLinearGradient(0, 0, 0, size);
        g.addColorStop(0, "#1f4b8f");
        g.addColorStop(0.55, "#1a3970");
        g.addColorStop(1, "#27344f");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, size, size);
        for (let y = 0; y < size; y += 24) {
            const wobble = Math.sin(y * 0.045) * 7;
            ctx.strokeStyle = "rgba(138,199,255,0.19)";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, y + wobble);
            ctx.quadraticCurveTo(size * 0.5, y - wobble, size, y + wobble);
            ctx.stroke();
        }
        for (let i = 0; i < 120; i += 1) {
            const x = Math.floor(Math.random() * size);
            const y = Math.floor(Math.random() * size);
            const alpha = 0.04 + Math.random() * 0.1;
            ctx.fillStyle = `rgba(220,240,255,${alpha.toFixed(3)})`;
            ctx.fillRect(x, y, 5, 5);
        }
    } else if (regionId === "mine") {
        ctx.fillStyle = "#58524a";
        ctx.fillRect(0, 0, size, size);
        for (let y = 0; y < size; y += 12) {
            for (let x = 0; x < size; x += 12) {
                const n = seeded2D(x, y, 2);
                const v = Math.floor(58 + n * 64);
                ctx.fillStyle = `rgb(${v},${v - 4},${v - 9})`;
                ctx.fillRect(x, y, 12, 12);
            }
        }
        for (let i = 0; i < 150; i += 1) {
            const x = Math.floor(Math.random() * size);
            const y = Math.floor(Math.random() * size);
            const r = 2 + Math.random() * 3.2;
            ctx.fillStyle = "rgba(196,188,176,0.18)";
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }
    } else if (regionId === "market") {
        ctx.fillStyle = "#797f8c";
        ctx.fillRect(0, 0, size, size);
        const tile = 32;
        for (let y = 0; y < size; y += tile) {
            for (let x = 0; x < size; x += tile) {
                const n = seeded2D(x, y, 3);
                const c = 110 + Math.floor(n * 42);
                ctx.fillStyle = `rgb(${c + 8},${c + 8},${c + 12})`;
                ctx.fillRect(x + 1, y + 1, tile - 2, tile - 2);
            }
        }
        ctx.strokeStyle = "rgba(55,60,72,0.35)";
        ctx.lineWidth = 1;
        for (let i = 0; i <= size; i += tile) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, size);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, i);
            ctx.lineTo(size, i);
            ctx.stroke();
        }
    } else {
        ctx.fillStyle = "#255434";
        ctx.fillRect(0, 0, size, size);
        for (let y = 0; y < size; y += 12) {
            for (let x = 0; x < size; x += 12) {
                const n = seeded2D(x, y, 4);
                const g = 88 + Math.floor(n * 68);
                const r = 24 + Math.floor(n * 28);
                const b = 26 + Math.floor(n * 24);
                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(x, y, 12, 12);
            }
        }
        for (let i = 0; i < 120; i += 1) {
            const x = Math.floor(Math.random() * size);
            const y = Math.floor(Math.random() * size);
            const alpha = 0.08 + Math.random() * 0.13;
            ctx.fillStyle = `rgba(30,96,44,${alpha.toFixed(3)})`;
            ctx.fillRect(x, y, 7, 7);
        }
    }

    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(2.2, 2.2);
    tex.needsUpdate = true;
    if (renderer?.capabilities?.getMaxAnisotropy) {
        tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy());
    }
    return tex;
}

function normalizeBubbleText(text, maxLen = 72) {
    const clean = String(text || "").replace(/\s+/g, " ").trim();
    if (!clean) return "Action executed";
    if (clean.length <= maxLen) return clean;
    return `${clean.slice(0, Math.max(8, maxLen - 3))}...`;
}

function bubbleTextFromAction(action) {
    if (!action) return "Action executed";
    const content = action.message || action.action || "action";
    return normalizeBubbleText(content, 72);
}

function createBubbleSprite(text) {
    const msg = normalizeBubbleText(text, 72);
    const width = Math.min(430, Math.max(240, msg.length * 8 + 96));
    return createTextSprite(msg, {
        width,
        height: 86,
        bg: "rgba(20, 22, 33, 0.95)",
        fg: "#f4f7ff",
        border: "rgba(127, 189, 255, 0.92)",
        font: "600 20px IBM Plex Sans"
    });
}

function clearBubble(model) {
    if (!model || !model.bubble) return;
    if (model.bubble.material && model.bubble.material.map) model.bubble.material.map.dispose();
    if (model.bubble.material) model.bubble.material.dispose();
    model.root.remove(model.bubble);
    model.bubble = null;
}

function showAgentBubble(model, text, durationMs = 3200) {
    if (!model || !model.root) return;
    clearBubble(model);
    model.bubble = createBubbleSprite(text);
    model.bubble.position.set(0, 5.1, 0);
    model.bubble.visible = true;
    model.bubbleBaseScale = model.bubble.scale.clone();
    model.bubbleUntil = performance.now() + durationMs;
    model.bubbleLift = (model.crowdIndex % 3) * 0.52 + Math.min(0.9, Math.floor(model.crowdIndex / 3) * 0.2);
    model.root.add(model.bubble);
}

function createBaseWorld() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x070911);
    scene.fog = new THREE.Fog(0x06070c, 120, 320);

    const root = document.getElementById("scene");
    if (!root) {
        throw new Error("Missing #scene container");
    }
    if (!window.WebGLRenderingContext) {
        throw new Error("WebGL not supported in this browser");
    }

    camera = new THREE.PerspectiveCamera(55, root.clientWidth / root.clientHeight, 0.1, 420);
    camera.position.copy(OVERVIEW_POS);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(root.clientWidth, root.clientHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    root.appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.maxPolarAngle = Math.PI * 0.485;
    controls.minDistance = 18;
    controls.maxDistance = 220;
    controls.target.set(0, 0, 0);

    clock = new THREE.Clock();
    raycaster = new THREE.Raycaster();
    pointer = new THREE.Vector2();

    renderer.domElement.addEventListener("pointerdown", onPointerDown);

    window.addEventListener("resize", () => {
        camera.aspect = root.clientWidth / root.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(root.clientWidth, root.clientHeight);
    });
}

function buildLighting() {
    const hemi = new THREE.HemisphereLight(0xd6edff, 0x17202b, 0.48);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xfff0c5, 2.34);
    sun.position.set(58, 74, -54);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 3072;
    sun.shadow.mapSize.height = 3072;
    sun.shadow.camera.near = 1;
    sun.shadow.camera.far = 260;
    sun.shadow.camera.left = -96;
    sun.shadow.camera.right = 96;
    sun.shadow.camera.top = 96;
    sun.shadow.camera.bottom = -96;
    sun.shadow.bias = -0.00018;
    scene.add(sun);

    const fill = new THREE.PointLight(0x8fc8ff, 0.264, 240);
    fill.position.set(-24, 20, 36);
    scene.add(fill);

    const sunPos = new THREE.Vector3(56, 79, -56);
    const sunOuter = new THREE.Mesh(
        new THREE.CircleGeometry(10.8, 72),
        new THREE.MeshBasicMaterial({
            color: 0xffb85c,
            transparent: true,
            opacity: 0.28,
            depthWrite: false,
            depthTest: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        })
    );
    sunOuter.position.copy(sunPos);
    scene.add(sunOuter);
    sunBillboards.push(sunOuter);

    const sunMiddle = new THREE.Mesh(
        new THREE.CircleGeometry(7.4, 72),
        new THREE.MeshBasicMaterial({
            color: 0xffcf7d,
            transparent: true,
            opacity: 0.38,
            depthWrite: false,
            depthTest: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        })
    );
    sunMiddle.position.copy(sunPos);
    scene.add(sunMiddle);
    sunBillboards.push(sunMiddle);

    const sunCore = new THREE.Mesh(
        new THREE.CircleGeometry(4.8, 72),
        new THREE.MeshBasicMaterial({
            color: 0xfff3cf,
            transparent: true,
            opacity: 0.92,
            depthWrite: false,
            depthTest: true,
            side: THREE.DoubleSide
        })
    );
    sunCore.position.copy(sunPos);
    scene.add(sunCore);
    sunBillboards.push(sunCore);

    const sunRing = new THREE.Mesh(
        new THREE.RingGeometry(11.6, 14.2, 96),
        new THREE.MeshBasicMaterial({
            color: 0xffd27f,
            transparent: true,
            opacity: 0.2,
            depthWrite: false,
            depthTest: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        })
    );
    sunRing.position.copy(sunPos);
    scene.add(sunRing);
    sunBillboards.push(sunRing);

    const sunAmbient = new THREE.PointLight(0xffd27a, 0.54, 420, 1.5);
    sunAmbient.position.copy(sunPos);
    scene.add(sunAmbient);
}

function buildGroundAndRoads() {
    const worldSize = WORLD_HALF * 2;

    const baseGround = new THREE.Mesh(
        new THREE.PlaneGeometry(worldSize + 36, worldSize + 36),
        new THREE.MeshStandardMaterial({ color: 0x1a2437, roughness: 0.95, metalness: 0.04 })
    );
    baseGround.rotation.x = -Math.PI / 2;
    baseGround.receiveShadow = true;
    scene.add(baseGround);

    const roadMat = new THREE.MeshStandardMaterial({ color: 0x4d525f, roughness: 0.9, metalness: 0.08 });
    const hRoad = new THREE.Mesh(new THREE.BoxGeometry(worldSize, 0.22, ROAD_WIDTH), roadMat);
    hRoad.position.set(0, 0.11, 0);
    hRoad.receiveShadow = true;
    scene.add(hRoad);

    const vRoad = new THREE.Mesh(new THREE.BoxGeometry(ROAD_WIDTH, 0.22, worldSize), roadMat);
    vRoad.position.set(0, 0.11, 0);
    vRoad.receiveShadow = true;
    scene.add(vRoad);

    const centerPlaza = new THREE.Mesh(
        new THREE.BoxGeometry(ROAD_WIDTH + 2.6, 0.24, ROAD_WIDTH + 2.6),
        new THREE.MeshStandardMaterial({ color: 0x666d7b, roughness: 0.82, metalness: 0.08 })
    );
    centerPlaza.position.set(0, 0.12, 0);
    centerPlaza.receiveShadow = true;
    scene.add(centerPlaza);

    const laneMat = new THREE.MeshBasicMaterial({ color: 0xcad3e4, transparent: true, opacity: 0.54 });
    for (let i = -WORLD_HALF + 6; i <= WORLD_HALF - 6; i += 5) {
        const laneX = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.04, 0.22), laneMat);
        laneX.position.set(i, 0.24, 0);
        scene.add(laneX);

        const laneZ = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.04, 1.9), laneMat);
        laneZ.position.set(0, 0.24, i);
        scene.add(laneZ);
    }

    const curbMat = new THREE.MeshStandardMaterial({ color: 0x787f8f, roughness: 0.78, metalness: 0.12 });
    const topCurb = new THREE.Mesh(new THREE.BoxGeometry(worldSize, 0.18, 0.28), curbMat);
    topCurb.position.set(0, 0.2, -ROAD_HALF);
    scene.add(topCurb);
    const bottomCurb = topCurb.clone();
    bottomCurb.position.set(0, 0.2, ROAD_HALF);
    scene.add(bottomCurb);
    const leftCurb = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.18, worldSize), curbMat);
    leftCurb.position.set(-ROAD_HALF, 0.2, 0);
    scene.add(leftCurb);
    const rightCurb = leftCurb.clone();
    rightCurb.position.set(ROAD_HALF, 0.2, 0);
    scene.add(rightCurb);

    const signPost = new THREE.Mesh(
        new THREE.CylinderGeometry(0.24, 0.24, 3.2, 10),
        new THREE.MeshStandardMaterial({ color: 0x735038, roughness: 0.8 })
    );
    signPost.position.set(0, 1.6, 0);
    signPost.castShadow = true;
    scene.add(signPost);

    const signBoardA = new THREE.Mesh(
        new THREE.BoxGeometry(4.8, 0.7, 0.25),
        new THREE.MeshStandardMaterial({ color: 0x946845, roughness: 0.78 })
    );
    signBoardA.position.set(0, 2.36, 0.58);
    scene.add(signBoardA);

    const signBoardB = new THREE.Mesh(
        new THREE.BoxGeometry(4.8, 0.7, 0.25),
        new THREE.MeshStandardMaterial({ color: 0x946845, roughness: 0.78 })
    );
    signBoardB.position.set(0, 1.56, -0.58);
    scene.add(signBoardB);

    const grid = new THREE.GridHelper(worldSize + 24, 64, 0x364969, 0x1f2b3f);
    grid.material.opacity = 0.2;
    grid.material.transparent = true;
    grid.position.y = 0.03;
    scene.add(grid);
}

function addDockProps(group) {
    const water = new THREE.Mesh(
        new THREE.BoxGeometry(16, 0.12, 9),
        new THREE.MeshStandardMaterial({ color: 0x2468d0, roughness: 0.3, metalness: 0.1, transparent: true, opacity: 0.88 })
    );
    water.position.set(0, 0.2, -3.5);
    group.add(water);

    const pierMat = new THREE.MeshStandardMaterial({ color: 0x7d5432, roughness: 0.85 });
    for (let i = -4; i <= 4; i += 2) {
        const pier = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.2, 3.2), pierMat);
        pier.position.set(i, 0.3, -0.4);
        group.add(pier);
    }

    const crateMat = new THREE.MeshStandardMaterial({ color: 0x9e7246, roughness: 0.8 });
    const crateA = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), crateMat);
    crateA.position.set(-3.2, 0.85, 2.3);
    crateA.castShadow = true;
    group.add(crateA);

    const crateB = crateA.clone();
    crateB.position.set(2.9, 0.85, 1.8);
    group.add(crateB);
}

function addMineProps(group) {
    const rockMat = new THREE.MeshStandardMaterial({ color: 0x65615d, roughness: 0.94 });
    const stones = [
        [-4, -1.2, 1.6],
        [-2, 1.5, 1.0],
        [0.5, -0.3, 1.8],
        [3.2, 0.8, 1.4],
        [4.4, -2.2, 1.2]
    ];
    stones.forEach((s) => {
        const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(s[2], 0), rockMat);
        rock.position.set(s[0], 0.9, s[1]);
        rock.castShadow = true;
        group.add(rock);
    });

    const crystalMat = new THREE.MeshStandardMaterial({ color: 0xd6dde9, emissive: 0x61738f, emissiveIntensity: 0.25, roughness: 0.35 });
    for (let i = 0; i < 5; i += 1) {
        const c = new THREE.Mesh(new THREE.ConeGeometry(0.42, 1.8, 6), crystalMat);
        c.position.set(-3 + i * 1.5, 1.05, 3);
        c.rotation.y = i * 0.7;
        group.add(c);
    }
}

function addMarketProps(group) {
    const stone = new THREE.Mesh(
        new THREE.BoxGeometry(14, 0.14, 9),
        new THREE.MeshStandardMaterial({ color: 0x858c9a, roughness: 0.93 })
    );
    stone.position.set(0, 0.2, 0);
    group.add(stone);

    const stallDefs = [
        { x: -3.8, z: -2.8, color: 0xdd5b4e },
        { x: -1.2, z: -2.8, color: 0x4e92ea },
        { x: 1.4, z: -2.8, color: 0xe2a432 },
        { x: 4.0, z: -2.8, color: 0x4bc672 }
    ];

    stallDefs.forEach((s) => {
        const base = new THREE.Mesh(
            new THREE.BoxGeometry(1.8, 1.2, 1.4),
            new THREE.MeshStandardMaterial({ color: 0x6f4b2d, roughness: 0.83 })
        );
        base.position.set(s.x, 0.8, s.z);
        base.castShadow = true;
        group.add(base);

        const roof = new THREE.Mesh(
            new THREE.BoxGeometry(2.1, 0.2, 1.7),
            new THREE.MeshStandardMaterial({ color: s.color, roughness: 0.7 })
        );
        roof.position.set(s.x, 1.55, s.z);
        roof.castShadow = true;
        group.add(roof);
    });
}

function addForestProps(group) {
    const treeTrunkMat = new THREE.MeshStandardMaterial({ color: 0x6f4b2f, roughness: 0.86 });
    const treeLeafMat = new THREE.MeshStandardMaterial({ color: 0x2ba452, roughness: 0.84 });

    const treePoints = [
        [-4.2, -2.6],
        [-2.4, -3.0],
        [0.1, -2.5],
        [2.2, -3.1],
        [4.0, -2.4],
        [-3.4, 0.2],
        [-1.2, 0.5],
        [1.6, 0.2],
        [3.6, 0.5],
        [-3.9, 2.6],
        [-1.6, 2.9],
        [0.8, 2.6],
        [3.0, 2.8]
    ];

    treePoints.forEach((p, idx) => {
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 1.2, 8), treeTrunkMat);
        trunk.position.set(p[0], 0.7, p[1]);
        trunk.castShadow = true;
        group.add(trunk);

        const leaf = new THREE.Mesh(new THREE.SphereGeometry(0.88 + (idx % 3) * 0.08, 12, 10), treeLeafMat);
        leaf.position.set(p[0], 1.65, p[1]);
        leaf.castShadow = true;
        group.add(leaf);
    });
}

function buildRegions() {
    REGION_IDS.forEach((regionId) => {
        const cfg = REGION_CONFIG[regionId];
        const group = new THREE.Group();
        group.position.set(cfg.center.x, 0, cfg.center.z);
        const sizeX = cfg.bounds.maxX - cfg.bounds.minX;
        const sizeZ = cfg.bounds.maxZ - cfg.bounds.minZ;

        const floorTex = makeRegionTexture(regionId);
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(sizeX, sizeZ),
            new THREE.MeshStandardMaterial({
                map: floorTex,
                color: 0xffffff,
                roughness: 0.94,
                metalness: 0.04,
                emissive: new THREE.Color(cfg.color).multiplyScalar(0.07),
                emissiveIntensity: 0.08
            })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0.04;
        floor.receiveShadow = true;
        floor.userData = { kind: "region", region: regionId };
        group.add(floor);
        clickableMeshes.push(floor);

        const borderMats = [];
        const edgeThickness = 0.42;
        const edgeHeight = 0.24;
        const makeEdge = (w, d, x, z) => {
            const mat = new THREE.MeshBasicMaterial({ color: cfg.color, transparent: true, opacity: 0.45 });
            borderMats.push(mat);
            const edge = new THREE.Mesh(new THREE.BoxGeometry(w, edgeHeight, d), mat);
            edge.position.set(x, 0.16, z);
            group.add(edge);
        };
        makeEdge(sizeX + edgeThickness, edgeThickness, 0, -sizeZ / 2);
        makeEdge(sizeX + edgeThickness, edgeThickness, 0, sizeZ / 2);
        makeEdge(edgeThickness, sizeZ + edgeThickness, -sizeX / 2, 0);
        makeEdge(edgeThickness, sizeZ + edgeThickness, sizeX / 2, 0);

        const label = createTextSprite(cfg.label, {
            width: 640,
            height: 180,
            bg: "rgba(9,16,30,0.86)",
            border: "rgba(108,171,255,0.55)",
            font: "700 74px Orbitron",
            scaleY: 6.2
        });
        label.position.set(0, 10.8, 0);
        group.add(label);

        const propsGroup = new THREE.Group();
        propsGroup.position.y = 0.06;
        const propScale = regionId === "forest" ? 4.6 : 4.1;
        propsGroup.scale.set(propScale, propScale, propScale);
        group.add(propsGroup);

        if (regionId === "dock") {
            addDockProps(propsGroup);
        } else if (regionId === "mine") {
            addMineProps(propsGroup);
        } else if (regionId === "market") {
            addMarketProps(propsGroup);
        } else if (regionId === "forest") {
            addForestProps(propsGroup);
        }

        group.userData = {
            region: regionId,
            floor,
            borderMats,
            baseEmission: 0.08,
            phase: Math.random() * Math.PI * 2
        };

        scene.add(group);
        regionMeshes[regionId] = group;
    });
}

function shortWallet(wallet) {
    if (!wallet) return "unknown";
    if (wallet.startsWith("placeholder-")) return wallet.replace("placeholder-", "");
    if (wallet.length <= 10) return wallet;
    return `${wallet.slice(0, 4)}...${wallet.slice(-4)}`;
}

function createAgentModel(agent) {
    const root = new THREE.Group();
    root.scale.set(1.82, 1.82, 1.82);
    const color = hashColor(agent.wallet);
    const displayName = agent.name || shortWallet(agent.wallet);

    const bodyMat = new THREE.MeshStandardMaterial({
        color,
        emissive: color.clone().multiplyScalar(0.22),
        emissiveIntensity: 0.2,
        roughness: 0.35,
        metalness: 0.2
    });

    const limbMat = new THREE.MeshStandardMaterial({ color: 0xd9e2ef, roughness: 0.55, metalness: 0.08 });

    const shadow = new THREE.Mesh(
        new THREE.CircleGeometry(0.95, 24),
        new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.28 })
    );
    shadow.rotation.x = -Math.PI / 2;
    shadow.position.y = 0.02;

    const torso = new THREE.Mesh(new THREE.CapsuleGeometry(0.45, 1.0, 6, 12), bodyMat);
    torso.position.set(0, 1.45, 0);
    torso.castShadow = true;

    const head = new THREE.Mesh(new THREE.SphereGeometry(0.38, 14, 12), limbMat);
    head.position.set(0, 2.45, 0);
    head.castShadow = true;

    const eye = new THREE.Mesh(
        new THREE.BoxGeometry(0.22, 0.06, 0.04),
        new THREE.MeshBasicMaterial({ color: 0x2f89ff })
    );
    eye.position.set(0, 2.46, 0.35);

    const armL = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.82, 8), limbMat);
    armL.position.set(-0.48, 1.56, 0);
    armL.rotation.z = 0.25;
    armL.castShadow = true;

    const armR = armL.clone();
    armR.position.set(0.48, 1.56, 0);
    armR.rotation.z = -0.25;

    const legL = new THREE.Mesh(new THREE.CylinderGeometry(0.14, 0.14, 0.9, 8), limbMat);
    legL.position.set(-0.2, 0.55, 0);
    legL.castShadow = true;

    const legR = legL.clone();
    legR.position.set(0.2, 0.55, 0);

    const backpack = new THREE.Mesh(
        new THREE.BoxGeometry(0.52, 0.64, 0.24),
        new THREE.MeshStandardMaterial({ color: 0x394963, roughness: 0.7 })
    );
    backpack.position.set(0, 1.45, -0.35);
    backpack.castShadow = true;

    const ring = new THREE.Mesh(
        new THREE.TorusGeometry(0.95, 0.08, 12, 34),
        new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.32 })
    );
    ring.rotation.x = Math.PI / 2;
    ring.position.y = 0.15;

    const label = createTextSprite(displayName, {
        width: 260,
        height: 64,
        bg: "rgba(8, 13, 21, 0.86)",
        border: "rgba(112, 170, 255, 0.55)",
        font: "600 24px IBM Plex Sans"
    });
    label.position.set(0, 3.45, 0);

    root.add(shadow, torso, head, eye, armL, armR, legL, legR, backpack, ring, label);

    [torso, head, armL, armR, legL, legR, backpack].forEach((mesh) => {
        mesh.userData = { kind: "agent", wallet: agent.wallet };
        clickableMeshes.push(mesh);
    });

    scene.add(root);

    return {
        root,
        ring,
        label,
        labelBaseScale: label.scale.clone(),
        bubble: null,
        bubbleBaseScale: null,
        bubbleUntil: 0,
        bubbleLift: 0,
        displayName,
        target: new THREE.Vector3(),
        route: [],
        speed: 6 + Math.random() * 2.4,
        phase: Math.random() * Math.PI * 2,
        moveBlend: 0,
        headingTarget: 0,
        crowdIndex: 0,
        crowdTotal: 1,
        data: agent,
        region: agent.region,
        selected: false,
        isPlaceholder: !!agent.placeholder,
        initialized: false,
        parts: {
            shadow,
            torso,
            head,
            armL,
            armR,
            legL,
            legR
        }
    };
}

function scatterPosition(regionId, idx, total) {
    const cfg = REGION_CONFIG[regionId] || REGION_CONFIG.dock;
    const count = Math.max(total, 1);
    const perRing = 8;
    const ring = Math.floor(idx / perRing);
    const ringIndex = idx % perRing;
    const densityBoost = Math.max(0, count - 4) * 0.62;
    const halfWidth = (cfg.bounds.maxX - cfg.bounds.minX) / 2;
    const halfDepth = (cfg.bounds.maxZ - cfg.bounds.minZ) / 2;
    const maxRadius = Math.max(8, Math.min(halfWidth, halfDepth) - 10);
    const angle = (ringIndex / perRing) * Math.PI * 2 + ring * 0.33;
    const radius = Math.min(maxRadius, 6 + densityBoost + ring * 4.1 + (ringIndex % 2) * 1.25);
    return new THREE.Vector3(
        cfg.center.x + Math.cos(angle) * radius,
        1.05,
        cfg.center.z + Math.sin(angle) * radius
    );
}

function buildRoute(model, toRegion, destination) {
    if (!model.region || model.region === toRegion) {
        return [destination.clone()];
    }

    const fromGate = REGION_CONFIG[model.region]?.gate || CROSSROAD;
    const toGate = REGION_CONFIG[toRegion]?.gate || CROSSROAD;

    const points = [
        new THREE.Vector3(fromGate.x, 1.05, fromGate.z),
        new THREE.Vector3(CROSSROAD.x, 1.05, CROSSROAD.z),
        new THREE.Vector3(toGate.x, 1.05, toGate.z),
        destination.clone()
    ];

    return points.filter((p, i) => {
        if (i === 0) return true;
        return p.distanceTo(points[i - 1]) > 0.3;
    });
}

function replaceLabel(model, text) {
    if (model.label && model.label.material) {
        if (model.label.material.map) model.label.material.map.dispose();
        model.label.material.dispose();
        model.root.remove(model.label);
    }
    model.label = createTextSprite(text, {
        width: 260,
        height: 64,
        bg: "rgba(8, 13, 21, 0.86)",
        border: "rgba(112, 170, 255, 0.55)",
        font: "600 24px IBM Plex Sans"
    });
    model.label.position.set(0, 3.45, 0);
    model.labelBaseScale = model.label.scale.clone();
    model.root.add(model.label);
}

function upsertAgents(renderAgents) {
    const wallets = new Set(renderAgents.map((a) => a.wallet));

    const regionGroups = {};
    REGION_IDS.forEach((r) => {
        regionGroups[r] = renderAgents.filter((a) => a.region === r);
    });

    renderAgents.forEach((agent) => {
        let model = agentModels.get(agent.wallet);
        if (!model) {
            model = createAgentModel(agent);
            agentModels.set(agent.wallet, model);
        }

        model.data = agent;
        const inRegion = regionGroups[agent.region] || [agent];
        const idx = Math.max(0, inRegion.findIndex((x) => x.wallet === agent.wallet));
        model.crowdIndex = idx;
        model.crowdTotal = Math.max(1, inRegion.length);
        const dest = scatterPosition(agent.region, idx, inRegion.length);
        model.target.copy(dest);

        if (!model.initialized) {
            model.root.position.copy(dest);
            model.initialized = true;
        } else {
            model.route = buildRoute(model, agent.region, dest);
        }

        model.region = agent.region;
        model.isPlaceholder = !!agent.placeholder;
        const displayName = agent.name || shortWallet(agent.wallet);
        if (model.displayName !== displayName) {
            replaceLabel(model, displayName);
            model.displayName = displayName;
        }
    });

    Array.from(agentModels.keys()).forEach((wallet) => {
        if (!wallets.has(wallet)) {
            const model = agentModels.get(wallet);
            clearBubble(model);
            model.root.traverse((obj) => {
                if (obj.material && obj.material.map && obj.material.map.dispose) {
                    obj.material.map.dispose();
                }
                if (obj.material && obj.material.dispose) {
                    obj.material.dispose();
                }
                if (obj.geometry && obj.geometry.dispose) {
                    obj.geometry.dispose();
                }
            });
            scene.remove(model.root);
            agentModels.delete(wallet);
        }
    });

    if (selectedAgentWallet && !agentModels.has(selectedAgentWallet)) {
        selectedAgentWallet = null;
    }

    syncSelectionHighlight();
}

function syncSelectionHighlight() {
    agentModels.forEach((model, wallet) => {
        model.selected = wallet === selectedAgentWallet;
        model.ring.material.opacity = model.selected ? 0.95 : 0.3;
        model.ring.material.color.set(model.selected ? 0xffffff : hashColor(wallet));
    });
    renderSelectedAgent();
}

function renderRegionsPanel() {
    const el = document.getElementById("region-list");
    const counts = {
        dock: 0,
        mine: 0,
        market: 0,
        forest: 0
    };

    latestAgents.forEach((a) => {
        if (counts[a.region] !== undefined) counts[a.region] += 1;
    });

    el.innerHTML = REGION_IDS.map((regionId) => {
        const cfg = REGION_CONFIG[regionId];
        const focus = selectedRegion === regionId ? "active" : "";
        return `
            <div class="card">
                <div class="row">
                    <div><span class="chip" style="border-color:#3a4b68;">${cfg.label}</span></div>
                    <div class="region-count">${counts[regionId]} agents</div>
                </div>
                <div class="row muted">${cfg.desc}</div>
                <div class="row">
                    <button class="btn ${focus}" data-region="${regionId}">Focus ${cfg.label}</button>
                </div>
            </div>
        `;
    }).join("");

    bindRegionButtons();
}

function renderAgentsPanel() {
    const el = document.getElementById("agent-list");
    if (!latestAgents.length) {
        el.innerHTML = '<div class="muted">No real agents yet. Placeholder bots are shown in 3D.</div>';
        return;
    }

    const sorted = [...latestAgents].sort((a, b) => b.credits - a.credits);
    el.innerHTML = sorted.map((a, idx) => {
        const selectedClass = a.wallet === selectedAgentWallet ? "active" : "";
        const rankClass = idx === 0 ? "rank-1" : idx === 1 ? "rank-2" : idx === 2 ? "rank-3" : "";
        const regionClass = ["dock", "mine", "forest", "market"].includes(a.region) ? `region-${a.region}` : "region-market";
        return `
            <div class="card">
                <div class="row">
                    <span class="rank-badge ${rankClass}">#${idx + 1}</span>
                    <button class="btn ${selectedClass}" data-select-wallet="${a.wallet}">Track</button>
                </div>
                <div class="agent-name">${a.name || shortWallet(a.wallet)}</div>
                <div class="row">
                    <span class="region-pill ${regionClass}">${a.region}</span>
                    <span class="credits-up">${a.credits} credits</span>
                </div>
                <div class="agent-meta">AP ${a.energy} | REP ${a.reputation ?? 0}</div>
                <div class="muted">Wallet ${shortWallet(a.wallet)}</div>
            </div>
        `;
    }).join("");

    document.querySelectorAll("[data-select-wallet]").forEach((btn) => {
        btn.addEventListener("click", () => {
            const wallet = btn.getAttribute("data-select-wallet");
            selectAgent(wallet);
            if (cameraMode === "follow") {
                focusSelectedAgent();
            }
        });
    });
}

function renderSelectedAgent() {
    const el = document.getElementById("agent-detail");
    if (!selectedAgentWallet || !agentModels.has(selectedAgentWallet)) {
        el.classList.add("muted");
        el.innerHTML = "Click an agent model to inspect details.";
        return;
    }

    const model = agentModels.get(selectedAgentWallet);
    const a = model.data || {};
    const inv = a.inventory ? Object.entries(a.inventory).map(([k, v]) => `${k}:${v}`).join(", ") : "-";

    el.classList.remove("muted");
    el.innerHTML = `
        <div class="agent-name">${a.name || shortWallet(a.wallet)}</div>
        <div class="agent-meta">Region ${a.region}</div>
        <div class="row"><span class="muted">Wallet</span><span>${shortWallet(a.wallet)}</span></div>
        <div class="row"><span class="muted">Credits</span><span class="accent">${a.credits ?? 0}</span></div>
        <div class="row"><span class="muted">Energy</span><span>${a.energy ?? 0}</span></div>
        <div class="row"><span class="muted">Reputation</span><span>${a.reputation ?? 0}</span></div>
        <div class="row"><span class="muted">Inventory</span><span>${inv || "-"}</span></div>
    `;
}

function renderEvents(events) {
    const el = document.getElementById("events");
    if (!events || !events.length) {
        el.innerHTML = '<div class="muted">No active events.</div>';
        return;
    }

    el.innerHTML = events.map((e) => `
        <div class="item">
            <div class="head">${e.type || "event"} (${e.remaining ?? "?"} ticks)</div>
            <div class="body">${e.description || ""}</div>
        </div>
    `).join("");
}

function renderActions(actions) {
    const el = document.getElementById("actions");
    if (!actions || !actions.length) {
        el.innerHTML = '<div class="muted">No recent actions.</div>';
        return;
    }

    const icons = {
        harvest: "⛏️",
        move: "🧭",
        place_order: "💰",
        rest: "🛏️",
        raid: "⚔️",
        negotiate: "🤝",
        register: "✅"
    };

    el.innerHTML = actions.map((a) => {
        const cls = a.success ? "ok" : "danger";
        const action = a.action || "action";
        const icon = icons[action] || "📝";
        return `
            <div class="item">
                <div class="head">${icon} ${shortWallet(a.wallet || "")} <span class="action-tag ${action}">${action}</span> <span class="${cls}">${a.success ? "ok" : "fail"}</span></div>
                <div class="body">${a.message || ""}</div>
                <div class="body muted">tick ${a.tick ?? "-"} | ${shortWallet(a.wallet || "")}</div>
            </div>
        `;
    }).join("");
}

function bindCameraButtons() {
    document.querySelectorAll("[data-camera]").forEach((btn) => {
        btn.addEventListener("click", () => {
            setCameraMode(btn.getAttribute("data-camera"));
        });
    });
}

function bindRegionButtons() {
    document.querySelectorAll("[data-region]").forEach((btn) => {
        if (btn.dataset.regionBound === "1") return;
        btn.dataset.regionBound = "1";
        btn.addEventListener("click", () => {
            const region = btn.getAttribute("data-region");
            focusRegion(region);
        });
    });
}

function bindViewButtons() {
    document.querySelectorAll("[data-view]").forEach((btn) => {
        if (btn.dataset.viewBound === "1") return;
        btn.dataset.viewBound = "1";
        btn.addEventListener("click", () => {
            const view = btn.getAttribute("data-view");
            if (view === "center") {
                centerCamera();
            }
        });
    });
}

function centerCamera() {
    selectedRegion = null;
    setCameraMode("overview");
    cameraGoal.copy(OVERVIEW_POS);
    lookGoal.set(0, 0, 0);
    renderRegionsPanel();
}

function updateCameraButtonState() {
    document.querySelectorAll("[data-camera]").forEach((btn) => {
        btn.classList.toggle("active", btn.getAttribute("data-camera") === cameraMode);
    });
}

function setCameraMode(mode) {
    cameraMode = mode;
    controls.enabled = mode === "free";
    updateCameraButtonState();

    if (mode === "overview") {
        if (!selectedRegion) {
            cameraGoal.copy(OVERVIEW_POS);
            lookGoal.set(0, 0, 0);
        }
    }

    if (mode === "follow") {
        focusSelectedAgent();
    }
}

function focusRegion(regionId) {
    if (!REGION_CONFIG[regionId]) return;

    selectedRegion = regionId;
    const cfg = REGION_CONFIG[regionId];

    setCameraMode("overview");
    cameraGoal.set(
        cfg.center.x + cfg.cameraOffset.x,
        cfg.cameraOffset.y,
        cfg.center.z + cfg.cameraOffset.z
    );
    lookGoal.set(cfg.center.x, 1.4, cfg.center.z);

    renderRegionsPanel();
    pulseRegion(regionId);
}

function pulseRegion(regionId) {
    REGION_IDS.forEach((id) => {
        const group = regionMeshes[id];
        if (!group) return;
        group.userData.baseEmission = id === regionId ? 0.24 : 0.08;
    });
}

function selectAgent(wallet) {
    selectedAgentWallet = wallet;
    syncSelectionHighlight();

    if (cameraMode === "follow") {
        focusSelectedAgent();
    }
}

function focusSelectedAgent() {
    if (!selectedAgentWallet || !agentModels.has(selectedAgentWallet)) {
        setCameraMode("overview");
        return;
    }

    const m = agentModels.get(selectedAgentWallet);
    const yaw = m.root.rotation.y;
    const behind = new THREE.Vector3(Math.sin(yaw) * 8, -7, Math.cos(yaw) * 8);
    cameraGoal.copy(m.root.position).sub(behind);
    lookGoal.copy(m.root.position).add(new THREE.Vector3(0, 1.8, 0));
}

function onPointerDown(event) {
    const rect = renderer.domElement.getBoundingClientRect();
    pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(pointer, camera);
    const intersects = raycaster.intersectObjects(clickableMeshes, true);
    if (!intersects.length) return;

    const hit = intersects[0].object;
    const data = hit.userData || {};

    if (data.kind === "region") {
        focusRegion(data.region);
    } else if (data.kind === "agent") {
        selectAgent(data.wallet);
    }
}

function updateRegionAnimations(timeSec) {
    REGION_IDS.forEach((regionId) => {
        const group = regionMeshes[regionId];
        if (!group) return;

        const highlight = Math.max(0, Math.sin(timeSec * 2.2 + group.userData.phase));
        const base = group.userData.baseEmission || 0.08;
        const floor = group.userData.floor;
        if (floor && floor.material && floor.material.emissiveIntensity !== undefined) {
            floor.material.emissiveIntensity = base + highlight * 0.08;
        }
        if (group.userData.borderMats) {
            group.userData.borderMats.forEach((mat) => {
                mat.opacity = 0.35 + highlight * 0.26 + base * 0.2;
            });
        }
    });
}

function advanceAgent(model, dt, timeSec) {
    const pos = model.root.position;
    const toTargetX = model.target.x - pos.x;
    const toTargetZ = model.target.z - pos.z;
    let moving = false;

    if (model.route.length > 0) {
        const next = model.route[0];
        const dir = new THREE.Vector3(next.x - pos.x, 0, next.z - pos.z);
        const dist = dir.length();
        const step = model.speed * dt;
        moving = dist > 0.03;

        if (dist <= step || dist < 0.05) {
            pos.x = next.x;
            pos.z = next.z;
            model.route.shift();
        } else {
            dir.normalize();
            pos.x += dir.x * step;
            pos.z += dir.z * step;
        }

        const lookX = model.route[0]?.x ?? model.target.x;
        const lookZ = model.route[0]?.z ?? model.target.z;
        model.headingTarget = Math.atan2(lookX - pos.x, lookZ - pos.z);
    } else {
        const remaining = Math.hypot(toTargetX, toTargetZ);
        moving = remaining > 0.06;
        pos.x += toTargetX * Math.min(1, dt * 3.2);
        pos.z += toTargetZ * Math.min(1, dt * 3.2);
        if (moving) {
            model.headingTarget = Math.atan2(toTargetX, toTargetZ);
        }
    }

    const yawDelta = Math.atan2(
        Math.sin(model.headingTarget - model.root.rotation.y),
        Math.cos(model.headingTarget - model.root.rotation.y)
    );
    model.root.rotation.y += yawDelta * Math.min(1, dt * 8);

    const moveTarget = moving ? 1 : 0;
    model.moveBlend += (moveTarget - model.moveBlend) * Math.min(1, dt * 7);

    const gait = Math.sin(timeSec * (7.8 + model.speed * 0.22) + model.phase) * 0.52 * model.moveBlend;
    const bob = Math.sin(timeSec * (4 + model.moveBlend * 4) + model.phase) * (0.05 + model.moveBlend * 0.08);
    pos.y = 1.0 + bob;

    if (model.parts) {
        model.parts.armL.rotation.x = gait;
        model.parts.armR.rotation.x = -gait;
        model.parts.legL.rotation.x = -gait * 0.9;
        model.parts.legR.rotation.x = gait * 0.9;
        model.parts.torso.rotation.x = 0.07 * model.moveBlend + Math.sin(timeSec * 2 + model.phase) * 0.03;
        model.parts.head.rotation.y = Math.sin(timeSec * 1.1 + model.phase) * 0.14;
        model.parts.shadow.scale.set(
            1 + model.moveBlend * 0.16,
            1 + model.moveBlend * 0.1,
            1
        );
        model.parts.shadow.material.opacity = 0.25 + model.moveBlend * 0.12;
    }

    model.ring.rotation.z += dt * 2.2;

    const stackLift = (model.crowdIndex % 3) * 0.44 + Math.min(1.0, Math.floor(model.crowdIndex / 3) * 0.18);
    const crowdScale = model.crowdTotal > 12 ? 0.56 : model.crowdTotal > 8 ? 0.65 : model.crowdTotal > 5 ? 0.74 : 0.9;
    model.label.position.y = 3.25 + stackLift + bob * 0.22;
    const sparseLabel = model.selected || model.crowdTotal <= 8 || model.crowdIndex < 6 || (model.crowdIndex % 2 === 0 && model.crowdTotal <= 16);
    model.label.visible = sparseLabel;
    if (model.labelBaseScale) {
        model.label.scale.set(
            model.labelBaseScale.x * crowdScale,
            model.labelBaseScale.y * crowdScale,
            model.labelBaseScale.z
        );
    }

    if (model.bubble) {
        const now = performance.now();
        const remainingMs = model.bubbleUntil - now;
        if (remainingMs <= 0) {
            model.bubble.visible = false;
        } else {
            model.bubble.visible = true;
            model.bubble.position.y = 5.05 + stackLift + model.bubbleLift + bob * 0.2;
            if (model.bubbleBaseScale) {
                const bubbleScale = Math.max(0.56, crowdScale * 0.9);
                model.bubble.scale.set(
                    model.bubbleBaseScale.x * bubbleScale,
                    model.bubbleBaseScale.y * bubbleScale,
                    model.bubbleBaseScale.z
                );
            }
            model.bubble.material.opacity = remainingMs < 460 ? Math.max(0.18, remainingMs / 460) : 1;
        }
    }
}

function updateCamera(dt) {
    if (cameraMode === "free") {
        controls.update();
        return;
    }

    if (cameraMode === "follow" && selectedAgentWallet && agentModels.has(selectedAgentWallet)) {
        const m = agentModels.get(selectedAgentWallet);
        const yaw = m.root.rotation.y;
        const behind = new THREE.Vector3(Math.sin(yaw) * 8, -7.5, Math.cos(yaw) * 8);
        cameraGoal.copy(m.root.position).sub(behind);
        cameraGoal.y = 8.5;
        lookGoal.copy(m.root.position).add(new THREE.Vector3(0, 1.8, 0));
    } else if (cameraMode === "overview" && !selectedRegion) {
        cameraGoal.copy(OVERVIEW_POS);
        lookGoal.set(0, 0, 0);
    }

    camera.position.lerp(cameraGoal, Math.min(1, dt * 2.4));
    controls.target.lerp(lookGoal, Math.min(1, dt * 2.8));
    camera.lookAt(controls.target);
}

function getRenderableAgents() {
    if (latestAgents.length > 0) {
        return latestAgents;
    }

    return REGION_IDS.map((regionId, i) => ({
        wallet: `placeholder-${regionId}`,
        name: `Awaiting-${regionId}`,
        region: regionId,
        credits: 0,
        energy: 100,
        inventory: {},
        reputation: 0,
        placeholder: true,
        rank: i + 1
    }));
}

function applyActionHints(actions) {
    const fresh = [];
    actions.forEach((a) => {
        const actionId = `${a.timestamp || ""}-${a.wallet || ""}-${a.action || ""}-${a.tick || ""}`;
        if (seenActionIds.has(actionId)) return;
        seenActionIds.add(actionId);
        fresh.push(a);
    });

    fresh.slice(0, 6).forEach((a) => {
        if (!a.wallet || !agentModels.has(a.wallet)) return;
        const m = agentModels.get(a.wallet);

        if (a.action === "move") {
            m.ring.material.opacity = 1;
            setTimeout(() => {
                if (!m.selected) m.ring.material.opacity = 0.3;
            }, 450);
        }

        const bubbleDuration = a.action === "move" ? 2200 : 3400;
        showAgentBubble(m, bubbleTextFromAction(a), bubbleDuration);
    });
}

async function pollWorld() {
    const data = await safeFetch("/world/state");
    if (!data) return;

    document.getElementById("tick").textContent = data.tick ?? "-";
    document.getElementById("agent-count").textContent = data.agent_count ?? latestAgents.length;
    const tax = (Number(data.tax_rate ?? 0.05) * 100).toFixed(0);
    document.getElementById("tax").textContent = `${tax}%`;

    document.getElementById("iron").textContent = `${data.market_prices?.iron ?? "-"}c`;
    document.getElementById("wood").textContent = `${data.market_prices?.wood ?? "-"}c`;
    document.getElementById("fish").textContent = `${data.market_prices?.fish ?? "-"}c`;

    renderEvents(data.active_events || []);
}

async function pollPyth() {
    const data = await safeFetch("/pyth/price", false);
    if (!data) return;
    const p = Number(data.price);
    if (Number.isFinite(p) && p > 0) {
        document.getElementById("sol-price").textContent = `$${p.toFixed(2)}`;
    } else {
        document.getElementById("sol-price").textContent = "-";
    }
}

async function pollAgents() {
    const data = await safeFetch("/agents");
    if (!data || !Array.isArray(data.agents)) return;

    latestAgents = data.agents;

    const renderAgents = getRenderableAgents();
    upsertAgents(renderAgents);

    renderRegionsPanel();
    renderAgentsPanel();
    renderSelectedAgent();
}

async function pollActions() {
    const data = await safeFetch("/actions/recent?limit=20");
    if (!data || !Array.isArray(data.actions)) return;

    activeActions = data.actions;
    renderActions(activeActions);
    applyActionHints(activeActions);
}

function animate() {
    requestAnimationFrame(animate);

    const dt = clock.getDelta();
    const t = clock.elapsedTime;

    updateRegionAnimations(t);
    agentModels.forEach((model) => advanceAgent(model, dt, t));
    sunBillboards.forEach((m) => {
        m.quaternion.copy(camera.quaternion);
    });
    updateCamera(dt);

    renderer.render(scene, camera);
}

async function boot() {
    createBaseWorld();
    buildLighting();
    buildGroundAndRoads();
    buildRegions();

    bindCameraButtons();
    bindRegionButtons();
    bindViewButtons();
    updateCameraButtonState();

    await Promise.all([pollWorld(), pollAgents(), pollActions(), pollPyth()]);

    setInterval(pollWorld, 3000);
    setInterval(pollAgents, 2400);
    setInterval(pollActions, 2200);
    setInterval(pollPyth, 8000);

    animate();
}

boot().catch((err) => {
    fatal(err && (err.stack || err.message) ? (err.stack || err.message) : String(err));
});
</script>
</body>
</html>
